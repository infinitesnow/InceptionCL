#include <convolution.hpp>

//#define DEBUG_LEVEL warning 
#define DEBUG_LEVEL trace 

void init_boost()
{
    logging::core::get()->set_filter
    (
        logging::trivial::severity >= logging::trivial::DEBUG_LEVEL
    );
};

inline void print_header(std::string s){
  using namespace std;
  print_separator(rang::fg::red,s.length()+4);
  cout << rang::fg::red << "║ " << s << " ║" << rang::style::reset << endl; 
  print_separator(rang::fg::red,s.length()+4);
}

int main(){
  // Let's initialize Boost logging system
  init_boost();

  BOOST_LOG_TRIVIAL(trace) << "Starting main";

  // Define input parameters
  const size_t input_width = 14;
  const size_t input_height = 14;
  const size_t input_depth = 3;
  const short stride=1;
  const int bias = 0;
  const int num11=128;
  const int num33reduce=128;
  const int num33=256;
  const int num55reduce=24;
  const int num55=64;
  const int poolproj=64; 

  /* 
   * Let's create the components of the Inception module. For each volume,
   * we first create a convolver object; weights are generated by a stub method.
   * Then, we apply the convolution/pool. 
  */
  print_header("Initializing volumes");
  Volume input_volume =Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol1 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol2 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol3 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol4 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol2_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol3_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol4_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));

  cl::sycl::queue q;
	    
  initialize_volume(input_volume, true, 255, q);
  initialize_volume(vol2_t,0,q);
  initialize_volume(vol3_t,0,q);
  initialize_volume(vol4_t,0,q);

  print_header("Initializing convolvers");
  Weights weights_1_11 = generate_stub_weights(1,input_depth,5,q);
  convolver c1_11(weights_1_11,stride,bias);
  c1_11.initialize(input_volume,q);

  Weights weights_2_11 = generate_stub_weights(1,input_depth,5,q);
  convolver c2_11(weights_2_11,stride,bias);
  c2_11.initialize(input_volume,q);
  Weights weights_2_33 = generate_stub_weights(3,5,3,q);
  convolver c2_33(weights_2_33,stride,bias);
  c2_33.initialize(vol2_t,q);
  
  Weights weights_3_11 = generate_stub_weights(1,input_depth,2,q);
  convolver c3_11(weights_3_11,stride,bias);
  c3_11.initialize(input_volume,q);
  Weights weights_3_55 = generate_stub_weights(2,2,6,q);
  convolver c3_55(weights_3_55,stride,bias);
  c3_55.initialize(vol3_t,q);

  convolver p4_33(3,1);
  p4_33.initialize(input_volume,q);
  Weights weights_4_11 = generate_stub_weights(1,input_depth,5,q);
  convolver c4_11(weights_4_11,stride,bias);
  c4_11.initialize(vol4_t,q);

  std::this_thread::sleep_for(std::chrono::seconds(3));

  print_header("Launching convolutions");
  c1_11.convolve();
  //c2_33.convolve();
  //c3_55.convolve();
  //c4_11.convolve();
  
  print_header("Concatenating");
  //Volume output = concatenate_volumes(Weights{vol1,vol2,vol3,vol4});
  print_header("Final output");
  //print_volume(output);
 
  std::this_thread::sleep_for(std::chrono::seconds(3));
  
  std::cout << "Finished." << std::endl;
  return 0;
};
