#include <convolution.hpp>

#define DEBUG_LEVEL trace 

void init_boost()
{
    logging::core::get()->set_filter
    (
        logging::trivial::severity >= logging::trivial::DEBUG_LEVEL
    );
};

inline void print_header(std::string s){
  using namespace std;
  print_separator(rang::fg::red,s.length()+2);
  cout << rang::fg::red << "║" << s << "║" << rang::style::reset << endl; 
  print_separator(rang::fg::red,s.length()+2);
}

int main(){
  // Let's initialize Boost logging system
  init_boost();

  BOOST_LOG_TRIVIAL(trace) << "Starting main";

  // Define input parameters
  const size_t input_width = 14;
  const size_t input_height = 14;
  const size_t input_depth = 3;
  const short stride=1;
  const int bias = 0;
  const int num11=128;
  const int num33reduce=128;
  const int num33=256;
  const int num55reduce=24;
  const int num55=64;
  const int poolproj=64; 

  /* 
   * Let's create the components of the Inception module. For each volume,
   * we first create a convolver object; weights are generated by a stub method.
   * Then, we apply the convolution/pool. 
  */
  print_header("Initializing volumes");
  Volume input_volume =Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol1 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol2 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol3 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol4 = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol2_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol3_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));
  Volume vol4_t = Volume(cl::sycl::range<3>(input_width,input_height,input_depth));

	    
  initialize_volume(input_volume, true, 255);
  initialize_volume(vol2_t,0);
  initialize_volume(vol3_t,0);
  initialize_volume(vol4_t,0);

  cl::sycl::queue q;

  print_header("Initializing convolvers");
  Weights weights_1 = generate_stub_weights(1,input_depth,5);
  convolver c11_1(weights_1,stride,bias);
  c11_1.initialize(input_volume,q);

  Weights weights_2_11 = generate_stub_weights(1,input_depth,5);
  convolver c11_2(weights_2_11,stride,bias);
  c11_2.initialize(input_volume,q);
  Weights weights_2_33 = generate_stub_weights(3,5,3);
  convolver c33_2(weights_2_33,stride,bias);
  c11_1.initialize(vol2_t,q);
  
  Weights weights_3_11 = generate_stub_weights(1,input_depth,2);
  convolver c11_3(weights_3_11,stride,bias);
  c11_3.initialize(input_volume,q);
  Weights weights_3_55 = generate_stub_weights(2,2,6);
  convolver c55_3(weights_3_55,stride,bias);
  c11_3.initialize(vol3_t,q);

  convolver p33_4(3,1);
  p33_4.initialize(input_volume,q);
  Weights weights_4 = generate_stub_weights(1,input_depth,5);
  convolver c11_4(weights_4,stride,bias);
  c11_3.initialize(vol4_t,q);

  print_header("Launching convolutions");
  c11_1.convolve();
  c33_2.convolve();
  c55_3.convolve();
  c11_4.convolve();
  
  print_header("Concatenating");
  Volume output = concatenate_volumes(Weights{vol1,vol2,vol3,vol4});
  print_header("Final output");
  print_volume(output);
  
  std::cout << "Finished." << std::endl;
  return 0;
};
